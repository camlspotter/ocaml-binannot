(***********************************************************************)
(*                                                                     *)
(*                           Objective Caml                            *)
(*                                                                     *)
(*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         *)
(*                                                                     *)
(*  Copyright 1996 Institut National de Recherche en Informatique et   *)
(*  en Automatique.  All rights reserved.  This file is distributed    *)
(*  under the terms of the GNU Library General Public License, with    *)
(*  the special exception on linking described in file ../LICENSE.     *)
(*                                                                     *)
(***********************************************************************)

(* $Id$ *)

(** The run-time library for parsers generated by [ocamlyacc]. *)

val symbol_start : unit -> int
(** [symbol_start] and {!Parsing.symbol_end} are to be called in the
   action part of a grammar rule only. They return the offset of the
   string that matches the left-hand side of the rule: [symbol_start()]
   returns the offset of the first character; [symbol_end()] returns the
   offset after the last character. The first character in a file is at
   offset 0. *)

val symbol_end : unit -> int
(** See {!Parsing.symbol_start}. *)

val rhs_start : int -> int
(** Same as {!Parsing.symbol_start} and {!Parsing.symbol_end}, but
   return the offset of the string matching the [n]th item on the
   right-hand side of the rule, where [n] is the integer parameter
   to [rhs_start] and [rhs_end]. [n] is 1 for the leftmost item. *)

val rhs_end : int -> int
(** See {!Parsing.rhs_start}. *)

val symbol_start_pos : unit -> Lexing.position;;
(** Same as [symbol_start], but return a [position] instead of an offset. *)

val symbol_end_pos : unit -> Lexing.position
(** Same as [symbol_end], but return a [position] instead of an offset. *)

val rhs_start_pos : int -> Lexing.position
(** Same as [rhs_start], but return a [position] instead of an offset. *)

val rhs_end_pos : int -> Lexing.position
(** Same as [rhs_end], but return a [position] instead of an offset. *)

val clear_parser : unit -> unit
(** Empty the parser stack. Call it just after a parsing function
   has returned, to remove all pointers from the parser stack
   to structures that were built by semantic actions during parsing.
   This is optional, but lowers the memory requirements of the
   programs. *)

exception Parse_error
(** Raised when a parser encounters a syntax error.
   Can also be raised from the action part of a grammar rule,
   to initiate error recovery. *)

val set_trace: bool -> bool
(** Control debugging support for [ocamlyacc]-generated parsers.
    After [Parsing.set_trace true], the pushdown automaton that
    executes the parsers prints a trace of its actions (reading a token,
    shifting a state, reducing by a rule) on standard output.
    [Parsing.set_trace false] turns this debugging trace off.
    The boolean returned is the previous state of the trace flag.
    @since 3.11.0
*)

(**/**)

(** {6  } *)

(** The following definitions are used by the generated parsers only.
   They are not intended to be used by user programs. *)

type parser_env =
  { mutable s_stack : int array;        (* States *)
    mutable v_stack : Obj.t array;      (* Semantic attributes *)
    mutable symb_start_stack : Lexing.position array; (* Start positions *)
    mutable symb_end_stack : Lexing.position array;   (* End positions *)
    mutable stacksize : int;            (* Size of the stacks *)
    mutable stackbase : int;            (* Base sp for current parse *)
    mutable curr_char : int;            (* Last token read *)
    mutable lval : Obj.t;               (* Its semantic attribute *)
    mutable symb_start : Lexing.position;      (* Start pos. of the current symbol*)
    mutable symb_end : Lexing.position;        (* End pos. of the current symbol *)
    mutable asp : int;                  (* The stack pointer for attributes *)
    mutable rule_len : int;             (* Number of rhs items in the rule *)
    mutable rule_number : int;          (* Rule number to reduce by *)
    mutable sp : int;                   (* Saved sp for parse_engine *)
    mutable state : int;                (* Saved state for parse_engine *)
    mutable errflag : int }             (* Saved error flag for parse_engine *)

val env : parser_env

type parse_tables =
  { actions : (parser_env -> Obj.t) array;
    transl_const : int array;
    transl_block : int array;
    lhs : string;
    len : string;
    defred : string;
    dgoto : string;
    sindex : string;
    rindex : string;
    gindex : string;
    tablesize : int;
    table : string;
    check : string;
    error_function : string -> unit;
    names_const : string;
    names_block : string }

exception YYexit of Obj.t

val yyparse :
  parse_tables -> int -> (Lexing.lexbuf -> 'a) -> Lexing.lexbuf -> 'b
val peek_val : parser_env -> int -> 'a
val is_current_lookahead : 'a -> bool
val parse_error : string -> unit

(* Added to implement a backtracking parser  *)
type parser_input =
    Start
  | Token_read
  | Stacks_grown_1
  | Stacks_grown_2
  | Semantic_action_computed
  | Error_detected

type parser_output =
    Read_token
  | Raise_parse_error
  | Grow_stacks_1
  | Grow_stacks_2
  | Compute_semantic_action
  | Call_error_function

external parse_engine :
    parse_tables -> parser_env -> parser_input -> Obj.t -> parser_output
    = "caml_parse_engine"

":" ; @EMACS@ -batch -l $0 "$@" ; status=$? ; : '--*-Emacs-Lisp-*--' <<';'

(require 'caml)

;;itz Fri Oct 30 13:08:37 PST 1998 support for creating TAGS files
(defun caml-tags-next-phrase ()
  (re-search-forward (concat "^" caml-phrase-start-keywords) nil 'move)
  (while (and (not (eobp))
              (or (caml-in-comment-p)
                  (caml-in-literal-p)
                  (not (let ((p (point)))
                         (condition-case nil
                             (caml-mark-phrase)
                           (error (goto-char p) nil))))))
    (forward-line 1))
  (not (eobp)))

(defun caml-tags-file (filename output-buffer)
  (let* ((basename (file-name-nondirectory filename))
         (done nil)
         (current-line 1)
         last-phrase-point file-buffer)
    (set-buffer output-buffer)
    (insert "\n" basename ",\n")
    (find-file-read-only filename)
    (caml-mode)
    (setq file-buffer (current-buffer))
    (goto-char (point-min))
    (setq last-phrase-point (point))
    (while (caml-tags-next-phrase)
      (save-excursion
        (re-search-forward caml-phrase-start-keywords)
        (let ((done nil))
          (while (not done)
            (cond
             ((looking-at "\\s ")
              (skip-syntax-forward " "))
             ((char-equal (following-char) ?\( )
              (forward-sexp 1))
             ((char-equal (following-char) ?')
              (skip-syntax-forward "w_"))
             ((looking-at "\\(type\\|rec\\)\\>")
              (goto-char (match-end 0)))
             (t (setq done t)))))
        (re-search-forward "\\(\\sw\\|\\s_\\)+")
        (beginning-of-line 1)
        (setq current-line
              (+ current-line (count-lines last-phrase-point (point))))
        (setq last-phrase-point (point))
        (end-of-line 1)
        (let ((output-line (format "%%s%d,%d\n"
                                   (buffer-substring last-phrase-point (point))
                                   (match-string 0)
                                   current-line
                                   (match-beginning 0))))          
          (set-buffer output-buffer)
          (insert output-line)))
      (exchange-point-and-mark))
    (kill-buffer file-buffer)))

(defsubst prefix-p (prefix str)
  (and (<= (length prefix) (length str))
       (string= prefix (substring str 0 (length prefix)))))

(defsubst eat-args (n)
  (setq command-line-args-left (nthcdr n command-line-args-left)))

;; see Emacs source file print.c
(defun print-error-message (data)
  (let ((errname (car data)) errmsg is-file-error tail i)
    (if (eq errname 'error)
        (progn
          (setq data (cdr data))
          (if (not (consp data)) (setq data nil))
          (setq errmsg (car data))
          (setq is-file-error nil))
      (setq errmsg (get errname 'error-message))
      (setq is-file-error (memq 'file-error (get errname 'error-conditions))))
    (setq tail (cdr-safe data))
    (if (and is-file-error tail)
        (setq errmsg (car tail) tail (cdr tail)))
    (if (stringp errmsg) (princ errmsg)
      (princ "peculiar error"))
    (setq i 0)
    (while (consp tail)
      (princ (if (eq i 0) ": " ", "))
      (if is-file-error (princ (car tail))
        (prin1 (car tail)))
      (setq tail (cdr tail) i (1+ i)))
    (princ "\n")))
   

(setq gc-cons-threshold 1000000)

(setq output-file "TAGS")
(setq append-flag nil)
(setq status 0)

(condition-case foobar
    (progn
      (while (and command-line-args-left
                  (let ((arg (car command-line-args-left)))
                    (cond
                     ((prefix-p arg "-output-file")
                      (setq output-file (nth 1 command-line-args-left))
                      (eat-args 2) t)
                     ((prefix-p arg "-append")
                      (setq append-flag t)
                      (eat-args 1) t)
                     (t nil)))))

      (find-file output-file)
      (if append-flag (goto-char (point-max))
        (erase-buffer))
      (let ((output-buffer (current-buffer)))
        (while command-line-args-left
          (caml-tags-file (car command-line-args-left) output-buffer)
          (setq command-line-args-left (cdr command-line-args-left)))
        (set-buffer output-buffer)
        (save-buffer 0)))
  (error (setq status 1) (print-error-message foobar)))

(kill-emacs status)

;

":" ; exit $status

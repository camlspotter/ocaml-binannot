/***********************************************************************/
/*                                                                     */
/*                           Objective Caml                            */
/*                                                                     */
/*            Xavier Leroy, projet Cristal, INRIA Rocquencourt         */
/*                                                                     */
/*  Copyright 1996 Institut National de Recherche en Informatique et   */
/*  Automatique.  Distributed only by permission.                      */
/*                                                                     */
/***********************************************************************/

/* $Id$ */

/* Asm part of the runtime system for the Sparc processor.  */
/* Must be preprocessed by cpp */

/* SunOS 4 and BSD prefix identifiers with _, Solaris does not */

#ifndef SYS_solaris

        .common _caml_required_size, 4, "bss"

#define Young_limit _young_limit
#define Young_ptr _young_ptr
#define Caml_last_context _caml_last_context
#define Caml_exception_pointer _caml_exception_pointer
#define Caml_required_size _caml_required_size
#define Caml_alloc _caml_alloc
#define Caml_call_gc _caml_call_gc
#define Garbage_collection _garbage_collection
#define Caml_c_call _caml_c_call
#define Caml_start_program _caml_start_program
#define Caml_program _caml_program
#define Raise_caml_exception _raise_caml_exception
#define Callback _callback
#define Callback2 _callback2
#define Callback3 _callback3
#define Caml_apply2 _caml_apply2
#define Caml_apply3 _caml_apply3
#define Mlraise _mlraise
#define System_frametable _system_frametable

#else

        .common caml_required_size, 4, 4

#define Young_limit young_limit
#define Young_ptr young_ptr
#define Caml_last_context caml_last_context
#define Caml_exception_pointer caml_exception_pointer
#define Caml_required_size caml_required_size
#define Caml_alloc caml_alloc
#define Caml_call_gc caml_call_gc
#define Garbage_collection garbage_collection
#define Caml_c_call caml_c_call
#define Caml_start_program caml_start_program
#define Caml_program caml_program
#define Raise_caml_exception raise_caml_exception
#define Callback callback
#define Callback2 callback2
#define Callback3 callback3
#define Caml_apply2 caml_apply2
#define Caml_apply3 caml_apply3
#define Mlraise mlraise
#define System_frametable system_frametable

#endif

#define Exn_ptr %l5
#define Alloc_ptr %l6
#define Alloc_limit %l7

#define Load(symb,reg)  sethi %hi(symb), %g1; ld [%g1 + %lo(symb)], reg
#define Store(reg,symb) sethi %hi(symb), %g1; st reg, [%g1 + %lo(symb)]
#define Address(symb,reg) sethi %hi(symb), reg; or reg, %lo(symb), reg

/* Allocation functions */

        .text
        .global Caml_alloc
        .global Caml_call_gc

/* Required size in %g2 */
Caml_alloc:
        ld      [Alloc_limit], %g1
        sub     Alloc_ptr, %g2, Alloc_ptr
        cmp     Alloc_ptr, %g1
        blu     Caml_call_gc
        nop
        retl
        nop

/* Required size in %g2 */
Caml_call_gc:
    /* Save %g2 (required size) */
        Store(%g2, Caml_required_size)
    /* Save exception pointer if GC raises */
        Store(Exn_ptr, Caml_exception_pointer)
    /* Save current allocation pointer for debugging purposes */
        Store(Alloc_ptr, Young_ptr)
    /* Allocate space on stack for caml_context structure and float regs */
        sub     %sp, 4 + 25*4 + 15*8, %sp
    /* Build caml_context structure on stack
       and save it into caml_last_context. */
        add     %sp, 96 + 15*8, %g2
        std     %o0, [%g2]
        std     %o2, [%g2 + 0x8]
        std     %o4, [%g2 + 0x10]
        std     %i0, [%g2 + 0x18]
        std     %i2, [%g2 + 0x20]
        std     %i4, [%g2 + 0x28]
        std     %l0, [%g2 + 0x30]
        std     %l2, [%g2 + 0x38]
        st      %l4, [%g2 + 0x40]
        st      %g3, [%g2 + 0x44]
        st      %g4, [%g2 + 0x48]
        st      %o7, [%g2 + 0x64]
        Store(%g2, Caml_last_context)
    /* Save the floating-point registers */
        add     %sp, 96, %g1
        std     %f0, [%g1]
        std     %f2, [%g1 + 0x8]
        std     %f4, [%g1 + 0x10]
        std     %f6, [%g1 + 0x18]
        std     %f8, [%g1 + 0x20]
        std     %f10, [%g1 + 0x28]
        std     %f12, [%g1 + 0x30]
        std     %f14, [%g1 + 0x38]
        std     %f16, [%g1 + 0x40]
        std     %f18, [%g1 + 0x48]
        std     %f20, [%g1 + 0x50]
        std     %f22, [%g1 + 0x58]
        std     %f24, [%g1 + 0x60]
        std     %f26, [%g1 + 0x68]
        std     %f28, [%g1 + 0x70]
    /* Call the garbage collector */
        call    Garbage_collection
        nop
    /* Restore return address and all regs used by the code generator */
        add     %sp, 96 + 15*8, %g2
        ldd     [%g2], %o0
        ldd     [%g2 + 0x8], %o2
        ldd     [%g2 + 0x10], %o4
        ldd     [%g2 + 0x18], %i0
        ldd     [%g2 + 0x20], %i2
        ldd     [%g2 + 0x28], %i4
        ldd     [%g2 + 0x30], %l0
        ldd     [%g2 + 0x38], %l2
        ld      [%g2 + 0x40], %l4
        ld      [%g2 + 0x44], %g3
        ld      [%g2 + 0x48], %g4
        ld      [%g2 + 0x64], %o7
        add     %sp, 96, %g1
        ldd     [%g1], %f0
        ldd     [%g1 + 0x8], %f2
        ldd     [%g1 + 0x10], %f4
        ldd     [%g1 + 0x18], %f6
        ldd     [%g1 + 0x20], %f8
        ldd     [%g1 + 0x28], %f10
        ldd     [%g1 + 0x30], %f12
        ldd     [%g1 + 0x38], %f14
        ldd     [%g1 + 0x40], %f16
        ldd     [%g1 + 0x48], %f18
        ldd     [%g1 + 0x50], %f20
        ldd     [%g1 + 0x58], %f22
        ldd     [%g1 + 0x60], %f24
        ldd     [%g1 + 0x68], %f26
        ldd     [%g1 + 0x70], %f28
    /* Reload alloc ptr */
        Load(Young_ptr, Alloc_ptr)
    /* Allocate space for block */
        Load(Caml_required_size, %g2)
        sub     Alloc_ptr, %g2, Alloc_ptr
    /* Return to caller */
        retl
        add     %sp, 4 + 25*4 + 15*8, %sp       /* in delay slot */

/* Call a C function from Caml */

        .global Caml_c_call
/* Function to call is in %g2 */
Caml_c_call:
    /* Build caml_context structure on stack
       and save it into caml_last_context.
       We don't fill the gc_regs section, because no registers
       are live across caml_c_call. */
        sub     %sp, 8, %sp
        st      %o7, [%sp + 100]
        add     %sp, 100 - 25*4, %o7
        Store(%o7, Caml_last_context)
    /* Save the exception handler and alloc pointer */
        Store(Exn_ptr, Caml_exception_pointer)
        sethi   %hi(Young_ptr), %g1
    /* Call the C function */
        call    %g2
        st      Alloc_ptr, [%g1 + %lo(Young_ptr)]        /* in delay slot */
    /* Reload return address */
        ld      [%sp + 100], %o7
    /* Reload alloc pointer */
        Load(Young_ptr, Alloc_ptr)
    /* Return to caller */
        retl
        add     %sp, 8, %sp                 /* in delay slot */

/* Start the Caml program */

        .global Caml_start_program
Caml_start_program:
    /* Save all callee-save registers */
        save    %sp, -96, %sp
    /* Address of code to call */
        Address(Caml_program, %l2)

    /* Code shared with callback* */
L108:
    /* Set up a callback link on the stack. */
        sub     %sp, 8, %sp
        Load(Caml_last_context, %l0)
        st      %l0, [%sp + 96]
    /* Set up a trap frame to catch exceptions escaping the Caml code */
        call    L111
        nop
        b       L110
        nop
L111:   sub     %sp, 8, %sp
        Load(Caml_exception_pointer, Exn_ptr)
        st      %o7, [%sp + 96]
        st      Exn_ptr, [%sp + 100]
        mov     %sp, Exn_ptr
    /* Reload allocation pointers */
        Load(Young_ptr, Alloc_ptr)
        Address(Young_limit, Alloc_limit)
    /* Call the Caml code */
L109:   call    %l2
        nop
    /* Pop trap frame and restore caml_exception_pointer */
        ld      [%sp + 100], Exn_ptr
        add     %sp, 8, %sp
        Store(Exn_ptr, Caml_exception_pointer)
    /* Pop callback link, restoring caml_last_context */
        ld      [%sp + 96], %l0
        add     %sp, 8, %sp
        Store(%l0, Caml_last_context)
    /* Save allocation pointer */
        Store(Alloc_ptr, Young_ptr)
    /* Move result where the C function expects it */
        mov     %o0, %i0        /* %i0 will become %o0 after restore */
    /* Reload callee-save registers and return */
        ret
        restore
L110:
    /* The trap handler */
        Store(Exn_ptr, Caml_exception_pointer)
        Store(Alloc_ptr, Young_ptr)
        ld      [%sp + 96], %l0
        Store(%l0, Caml_last_context)
    /* Re-raise the exception through mlraise,
       so that local C roots are cleaned up correctly. */
        call    Mlraise         /* never returns */
        nop

/* Raise an exception from C */

        .global Raise_caml_exception
Raise_caml_exception:
    /* Save exception bucket in a register outside the reg windows */
        mov     %o0, %g2
    /* Load exception pointer in a register outside the reg windows */
        Load(Caml_exception_pointer, %g3)
    /* Pop some frames until the trap pointer is in the current frame. */
        cmp     %g3, %fp
        blt     L107                    /* if Exn_ptr < %fp, over */
        nop
L106:   restore
        cmp     %fp, %g3                /* if %fp <= Exn_ptr, loop */
        ble     L106
        nop
L107:
    /* Reload allocation registers */
        Load(Young_ptr, Alloc_ptr)
        Address(Young_limit, Alloc_limit)
    /* Branch to exception handler */
        mov     %g3, %sp
        ld      [%sp + 96], %g1
        ld      [%sp + 100], Exn_ptr
        add     %sp, 8, %sp
        jmp     %g1 + 8
    /* Restore bucket, in delay slot */
        mov     %g2, %o0

/* Callbacks C -> ML */

        .global Callback
Callback:
    /* Save callee-save registers and return address */
        save    %sp, -96, %sp
    /* Initial shuffling of arguments */
        mov     %i0, %g1
        mov     %i1, %i0        /* first arg */
        mov     %g1, %i1        /* environment */
        b       L108
        ld      [%g1], %l2      /* code pointer */

        .global Callback2
Callback2:
    /* Save callee-save registers and return address */
        save    %sp, -104, %sp
    /* Initial shuffling of arguments */
        mov     %i0, %g1
        mov     %i1, %i0        /* first arg */
        mov     %i2, %i1        /* second arg */
        mov     %g1, %i2        /* environment */
        sethi   %hi(Caml_apply2), %l2
        b       L108
        or      %l2, %lo(Caml_apply2), %l2

        .global Callback3
Callback3:
    /* Save callee-save registers and return address */
        save    %sp, -104, %sp
    /* Initial shuffling of arguments */
        mov     %i0, %g1
        mov     %i1, %i0        /* first arg */
        mov     %i2, %i1        /* second arg */
        mov     %i3, %i2        /* third arg */
        mov     %g1, %i3        /* environment */
        sethi   %hi(Caml_apply3), %l2
        b       L108
        or      %l2, %lo(Caml_apply3), %l2

        .data
        .global System_frametable
System_frametable:
        .word   1               /* one descriptor */
        .word   L109            /* return address into callback */
        .half   -1              /* negative frame size => use callback link */
        .half   0               /* no roots */
